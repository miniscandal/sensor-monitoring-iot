✰
	publish

	statud connected = 22
	.\mosquitto_pub -t "sensor-monitoring" -m '{"sensorId": 3, "status": 22}'

	status reading parameters = 32
	.\mosquitto_pub -t "sensor-monitoring" -m '{"sensorId": 3, "status": 32, "humidity": 51, "temperature": 9}'










✰ Ideas para mejoras futuras

- **Servicio de seguimiento de errores**: Implementar un servicio de seguimiento de errores, como Sentry o LogRocket, podría ayudar a identificar y solucionar problemas de manera más eficiente.
- **Sistema de registro**: Un sistema de registro más robusto podría proporcionar información valiosa sobre el comportamiento de la aplicación en tiempo real y ayudar a identificar áreas de mejora.












/**
 * Module responsibility
 */

import mqtt from 'mqtt';

class MqttClient {
	protected client: mqtt.MqttClient;

	constructor() {
		this.client = mqtt.connect(import.meta.env.VITE_MQTT_BROKER);
	}

	end(): void {
		this.client.end();
	}

	publish(topic: string, message: string): void {
		const data = JSON.stringify(message);
		this.client.publish(topic, data);
	}

	subscribe(topic: string, message: string): void {
		this.client.subscribe(topic, (error: Error) => {
			if (error !== null && error !== undefined) {
				console.error(`Error subscribing to topic ${topic}:`, error);
			}
			this.publish(topic, message);
		});
	}

	unsubscribe(topic: string): void {
		this.client.unsubscribe(topic, (error: Error) => {
			if (error !== null && error !== undefined) {
				console.error(`Error unsubscribedime  to topic ${topic}:`, error);
			}
		});
	}
}

export { MqttClient };




import mqtt from 'mqtt';

import { publishSubscribe } from '@shared-constants/mqtt-client-publish';
import { notifyConnected } from '@shared-constants/mqtt-client-notify';

const client = mqtt.connect(import.meta.env.VITE_MQTT_BROKER);

class MqttClientSingleton {
	static instance: MqttClientSingleton;

	private client: any;
	private observers: any[] = [];

	constructor(client: any) {
		if (MqttClientSingleton.instance) {
			return MqttClientSingleton.instance;
		}
		this.client = client;
		this.onConnect = this.onConnect.bind(this);
		this.onMessage = this.onMessage.bind(this);
		this.onReconnect = this.onReconnect.bind(this);
		this.configureClient();
	}

	static getInstance() {
		if (!MqttClientSingleton.instance) {
			MqttClientSingleton.instance = new MqttClientSingleton(client);
		}

		return MqttClientSingleton.instance;
	}

	private configureClient() {
		this.client.on('connect', this.onConnect);
		this.client.on('message', this.onMessage);
		this.client.on('reconnect', this.onReconnect);
	}

	private onConnect() {
		this.observerNotify(notifyConnected);
		this.subscribe(publishSubscribe);
	}

	private onMessage(topic: string, message: string) {
		const onMessage = { topic, message: JSON.parse(message) };

		this.observerNotify(onMessage);
	}

	private onReconnect() {
		this.observerNotify(notifyConnected);
	}

	end() {
		this.client.end();
	}

	publish({ topic, message }) {
		const data = JSON.stringify({ ...message });
		this.client.publish(topic, data);
	}

	subscribe({ topic = '', message = {} }) {
		this.client.subscribe(topic, (err) => {
			if (!err) {
				this.publish({ topic, message });
			}
		});
	}

	unsubscribe({ topic = '' }) {
		this.client.unsubscribe(topic, (err) => {
			if (!err) {
				return;
			}
		});
	}

	addObserver(observer) {
		this.observers.push({ observer });
	}

	removeObserver(observer) {
		this.observers = this.observers.filter(obs => obs !== observer);
	}

	protected retrieveClientProperties() {
		const { connected, options } = this.client;
		const { clientId, host, port, protocol } = options;

		return {
			clientMqtt: connected ? 'Connected' : 'Disconnecting',
			clientId,
			host,
			port,
			protocol,
			connected
		};
	}

	protected observerNotify(data) {
		this.observers.forEach(({ observer }) => {
			observer({ data, properties: this.retrieveClientProperties() })
		});
	}
}

new MqttClientSingleton(client);

export { MqttClientSingleton };
